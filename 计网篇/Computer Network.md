# 计算机网络篇

#### 1. 常见的HTPP请求方法和其区别

| 请求方法 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| GET      | 直接从服务器请求资源，一般不会对服务器资源造成影响，浏览器一般会对GET请求申请缓存，其请求报文中的实体部分为空，还可以将请求参数放入url中向服务器发送 |
| POST     | POST请求请求的报文中实体部分一般为向服务器发送的数据，一般用于对服务器资源会产生影响，其参数传递支持更多的数据类型 |
| PUT      | 更新整体资源，但不会增添数据                                 |
| PATCH    | 更新局部资源，也不会增添数据                                 |
| DELETE   | 删除服务器上的数据                                           |

------

#### 2. 常见的HTTP请求头和响应头

- HTTP Request Header 请求头：

  | 请求头          | 描述                                                         |
  | --------------- | ------------------------------------------------------------ |
  | Accept          | 浏览器能够处理的内容类型                                     |
  | Accept-Charset  | 浏览器能够显示的字符集                                       |
  | Accept-Encoding | 浏览器能够处理的压缩编码                                     |
  | Accept-Language | 浏览器当前设置的语言                                         |
  | Connection      | 浏览器与服务器之间连接的类型                                 |
  | Cookie          | 当前页面设置的任何Cookie                                     |
  | Host            | 发出请求的页面所在的域                                       |
  | Referer         | 发出请求的页面的URL                                          |
  | User-Agent      | 浏览器的用户代理字符串                                       |
  | OPTIONS         | 在对资源采集前，决定对资源采取某种措施或是了解服务器的性能，主要用于资源嗅探和检查访问权限 |

- HTTP Responses Header 响应头：

  | 响应头        | 描述                         |
  | ------------- | ---------------------------- |
  | Date          | 表示消息发送的时间           |
  | Server        | 服务器名称                   |
  | Connection    | 浏览器与服务器之间连接的类型 |
  | Cache-Control | 控制HTTP缓存                 |
  | Content-Type  | 表示后面的文档所属的类型     |

------

#### 3. HTTP状态码304是多好还是少好

服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。但是搜索引擎会更加青睐资源频繁更新的网站。若网站在一定时间内一直处于304的状态，那么爬虫可能会降低对网站的抓取次数。因此这件事是有好有坏的，需要项目负责人衡量利弊。

------

#### 4. HTTP 1.0和HTTP 1.1 之间的区别

- 连接：http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接，多个HTTP请求公用一次TCP连接，减少建立连接而产生的延时
- 资源请求：在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接
- 缓存：在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略
- http 1.1新增：新增了host字段，用来指定服务器的域名；新增一些请求方法，如PUT、OPTIONS等

------

#### 5. HTTP 1.1 和 HTTP 2.0 的区别

- 二进制协议：在 HTTP 1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP 2.0 中则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础
- 多路复用：HTTP 2.0 仍然复用 TCP 连接，但实现了多路复用，在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了"队头堵塞"的问题
- 数据流：HTTP 2.0 使用了数据流的概念，因为 HTTP 2.0 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP 2.0 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流
- 头信息压缩：HTTP 2.0 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP 2.0 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了
- 服务器推送：HTTP 2.0 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。

------

#### 6. HTTP和HTTPS的区别

- HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议
- HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL或TSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全
- HTTPS协议需要CA证书，费用较高；而HTTP协议不需要
- 使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443

------

#### 7. 在浏览器地址栏中输入url后按下回车发生了什么

- 缓存检查：浏览器会先检查URL是否合法，如果合法再判断是否完整，如果不完整会补全；如果不合法会走浏览器默认的搜索引擎；从URL中提取域名，操作系统会先检查缓存和本地Host是否有记录，如果有记录会直接完成域名解析；没有记录会继续检查本地DNS服务器是否有缓存，有的话会完成域名解析
- DNS解析：本地DNS服务器若没有找到域名地址的话会发送查询报文到根DNS服务器，并返回顶级域DNS服务器地址，本地DNS服务器再去向顶级域DNS服务器发送查询报文并返回权威DNS服务器地址，本地DNS服务器最后向权威DNS服务器发送查询报文最后拿到目的IP地址，完成域名解析
- 建立TCP连接的三次握手：首先客户端向服务器发送SYN包；服务器在收到请求后会回复客户端应该SYN+ACK包，确认连接请求；客户端收到后会进入连接状态并回复ACK包，服务端收到后也会立刻进入连接状态
- 返回数据：当页面请求发送到服务器后，服务器会返回指定的HTML文件，浏览器收到响应后会对HTML文件进行解析，开始页面渲染
- 页面渲染：浏览器首先根据HTML文件构建DOM树，再根据解析到的CSS文件构建样式表，连接DOM树和样式表形成渲染树，根据渲染树浏览器会对页面进行布局并调用UI接口对页面进行重排重绘
- TCP四次挥手：（这一步不一定会发生，因为现代浏览器大多都是默认开启持久连接模式，一直到用户关闭页签才会中断TCP连接）若客户端确认数据发送完成，则会向服务器发送FIN包，自身进入终止等待1状态；服务器收到后回复ACK包并进入关闭等待状态；客户端收到后进入终止等待2状态；此时服务器还能发送数据，客户端还能接收数据；待服务器确认数据已经发送完毕后，会再对客户端发送FIN包；客户端收到后回复ACK包并进入超时等待状态；服务器收到ACK包会立即关闭连接；等待一定时间后客户端会自动关闭连接

------

