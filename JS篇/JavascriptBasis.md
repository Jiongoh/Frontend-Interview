# Javascript基础

#### 1. JS中的数据类型

JS共有八种数据类型，分别是 undefined、null、Boolean、Number、String、Object、Symbol、BigInt

这些数据可以根据在内存中存储的位置分为原始数据类型和引用数据类型：

- 栈：原始数据类型，如undefined、null、Boolean、Number、String
- 堆：引用数据类型，如对象、数组和函数

------

#### 2. 数据类型检测的方式有哪些

- typeof：数组、对象、null都会被判断为object，其余判断都是正确的

  ```js
  typeof 2  //Number
  ```

- instanceof：可以正确判断对象的类型，**其内部运行机制是判断在其原型链中能否找到该类型的原型**

  ```js
  2 instanceof Number  //true
  ```

- constructor：有两个作用，一是判断数据的类型，二是对象实例通过 `constrcutor` 对象访问它的构造函数

  ```js
  (2).constructor === Number  //true
  ```

- Object.prototype.toString.call()：使用 Object 对象的原型方法 toString 来判断数据类型

  ```js
  Object.prototype.toString.call(2)  //'[object Number]'
  ```

------

#### 3. 判断数组的方法

- 通过Object.prototype.toString.call()做判断：****

  ```js
  Object.prototype.toString.call(obj).slice(8,-1) === 'Array';
  ```

- 通过原型链做判断：

  ```js
  obj.__proto__ === Array.prototype;
  ```

- 通过Array.isArray()做判断：

  ```js
  Array.isArrray(obj);
  ```

- 通过instanceof做判断：

  ```js
  obj instanceof Array  
  ```

- 通过Array.prototype.isPrototypeOf：

  ```js
  Array.prototype.isPrototypeOf(obj)
  ```

------

#### 4. null和undefined的区别

undefined的含义是**未定义**，null的含义是**空对象**。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化

> 注意：undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的

------

#### 5. typeof null 的结果是什么，为什么

typeof null 的结果是Object

原因：在初代JS中，所有的值都存储在32位的单元中，每一个单元都有一个类型标签，类型标签存储在低位中，Object的标识码符刚好是000。而null对应机器码的null指针标识码全部为0，低位也是0，因此typeof null的值也被判定为Object

------

#### 6. 0.1+0.2为什么不等于0.3

因为在计算机中数据的存储是二进制的，0.1和0.2转化为二进制都是无限循环的二进制小数，二者相加导致位数溢出，从而导致丢失了精度

------

#### 7. NaN

NaN指“Not a Number”，属于一个警戒值，用于指出数字类型中的错误情况，即执行数学运算没有成功。但是typeof NaN得到的结果是number。并且NaN也是唯一一个自己和自己比较是不相等的，即NaN === NaN的值是false

------

#### 8. isNaN 和 Number.isNaN 函数的区别

- isNaN：首先尝试将参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断
- Number.isNaN：首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确

------

#### 9. 其他值到字符串的转换规则

- null和undefined 类型：null 转换为"null"，undefined转换为 "undefined"
- Boolean类型：true转换为 "true"，false 转换为"false"
- Number类型：直接转换，不过极小和极大的数字会使用指数形式
- Symbol类型：直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误
- 对普通对象来说，除非自行定义`toString()`方法，否则会调用`toString()`（Object.prototype.toString()）来返回内部属性[[Class]]的值，如"[object Object]"

------

#### 10. 其他值到数字的转化规则

- undefined类型：转化为NaN
- null类型：转化为0
- Boolean类型：true转化为1，false转化为0
- String类型：包含非数字值的转化为NaN，空字符串转化为0
- Symbol类型：无法转化，会报错
- 对象（包括数组）类型会先转化为相对于的基本类型，如果返回的是非数字的基本类型，则再遵循上述规则强制转化为数字

------

#### 11. 其他值到布尔值的转化规则

除了undefined、null、0、NaN转化为false，其他全部是true

------

#### 12. 关于||和&&

- 对于||来说，如果第一个操作数值为true就会返回第一个操作值的值，如果为false就返回第二个操作数的值
- &&则相反，如果第一个操作数的值为true则返回第二个操作数的值，如果是false就返回第一个数的值

------

#### 13. Object.is() 与比较操作符 “===”、“==” 的区别

- 使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较
- 使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false
- 使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如-0 和+0不相等，两个NaN是相等的

------

#### 14. let、const、var的区别

| 区别               | var  | let  | const |
| ------------------ | ---- | ---- | ----- |
| 块级作用域         | ×    | ✔️    | ✔️     |
| 变量提升           | ✔️    | ×    | ×     |
| 是否添加全局属性   | ✔️    | ×    | ×     |
| 能否重复声明       | ✔️    | ×    | ×     |
| 暂时性死区         | ×    | ✔️    | ✔️     |
| 是否必须设置初始值 | ×    | ×    | ✔️     |
| 能否改变指针指向   | ✔️    | ✔️    | ×     |

------

#### 15.  const声明的对象的属性可以修改吗

可以。因为const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。

但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。

------

#### 16. 如果new一个箭头函数的会怎么样

会报错，因为将构造函数的作用域赋给新对象，将this指向实例对象这些都new操作符做的，而箭头函数没有prototype，也没有自己的this指向。因此无法new一个箭头函数

------

#### 17. 箭头函数与普通函数的区别

- 箭头函数写起来更简洁：箭头函数没有参数可以只写一个空括号，只有一个参数可以省略括号；函数体的返回值如果只有一句，可以省略大括号
- 箭头函数没有自己的this，只会自动捕获上下文的this
- 修改this指向的方法（call、apply、bind）无法改变箭头函数的this指向
- 箭头函数不能作为构造函数（不能使用new操作符）
- 箭头函数不能使用arguments对象
- 箭头函数没有prototype
- 箭头函数不能用作Generator函数，不能使用yeild关键字

------

#### 18. 解构赋值的理解

解构是ES6提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值

- 数组结构：在解构数组时，以元素的位置为匹配条件来提取想要的数据的

  ```js
  const [a, b, c] = [1, 2, 3];  //a=1,b=2,c=3
  const [d,,f] = [1,2,3]  //d=1,f=3
  ```

- 对象结构：以严格的属性的名称为匹配条件，来提取想要的数据

  ```js
  const stu = {
    name: 'Bob',
    age: 24
  };
  const { age, name } = stu  //age=24,name='Bob'
  ```

------

#### 19. 对arguments对象的理解

扩展运算符被用在函数形参上时，**它还可以把一个分离的参数序列整合成一个数组**

```js
function mutiple(...args) {
  console.log(args)
}
mutiple(1, 2, 3, 4) // [1, 2, 3, 4]
```

------

#### 20. new操作符的原理

- 首先创建了一个新的空对象
- 设置原型，将对象的原型设置为函数的 prototype 对象
- 让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）
- 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象

------

#### 21. Map和Object的区别

|          | Map                                                          | Object                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 意外的键 | Map默认情况不包含任何键，只包含显式插入的键。                | Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。 |
| 键的类型 | Map的键可以是任意值，包括函数、对象或任意基本类型。          | Object 的键必须是 String 或是Symbol。                        |
| 键的顺序 | Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。 | Object 的键是无序的                                          |
| Size     | Map 的键值对个数可以轻易地通过size 属性获取                  | Object 的键值对个数只能手动计算                              |
| 迭代     | Map 是 iterable 的，所以可以直接被迭代。                     | 迭代Object需要以某种方式获取它的键然后才能迭代。             |
| 性能     | 在频繁增删键值对的场景下表现更好。                           | 在频繁添加和删除键值对的场景下未作出优化。                   |

------

#### 22.  JavaScript 类数组对象

一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果。

常见的类数组转换为数组的方法如下：

- 通过 call 调用数组的 slice 方法来实现转换

  ```js
  Array.prototype.slice.call(arrayLike);
  ```

- 通过 call 调用数组的 splice 方法来实现转换

  ```js
  Array.prototype.splice.call(arrayLike, 0);
  ```

- 通过 apply 调用数组的 concat 方法来实现转换

  ```js
  Array.prototype.concat.apply([], arrayLike);
  ```

- 通过 Array.from 方法来实现转换

  ```js
  Array.from(arrayLike);
  ```

------

#### 23. 操作数组的方法，越多越好

- 数组转化成字符串：`toString()`、`toLocalString()`、`join()`
- 数组尾部增删：`push()`、`pop()`
- 数组首部增删：`shift()`、`unshift()`
- 对数组重排序：`reverse()`、`sort()`
- 数组拼接：`concat()`
- 数组截取：`slice()`
- 数组指定位置插入元素：`splice()`
- 根据条件查找数组元素：`indexOf()`、`find()`
- 遍历、迭代的方法：`filer()`、`map()`、`forEach()`
- 数组归并：`reduce()`

------

#### 24. 如何遍历类数组

- 使用Array.from方法将类数组转化成数组：‌

  ```js
  const arrArgs = Array.from(arguments) 
  arrArgs.forEach(a => console.log(a))
  ```

- 使用展开运算符将类数组转化成数组：

  ```js
  const arrArgs = [...arguments] 
  arrArgs.forEach(a => console.log(a)) 
  ```

------

#### 25. 什么是DOM和BOM

- DOM指的是文档对象模型，把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口
- BOM 指的是浏览器对象模型，是把浏览器当做一个对象来对待，而其核心就是window，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在

------

#### 26.  JavaScript为什么要进行变量提升

JS中存在一种现象叫变量提升，具体表现在无论在函数中何处位置用var声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。

进行变量提升的原因是：

- 为了提高性能，因为函数和声明变量的这些代码后续是不会变更的，只需要再编译阶段解析一遍就好
- 更好的容错性，让一些稍微不规范的代码也能运行

------

#### 27. **ES6**模块与**CommonJS**模块的不同点

- 语法上：ES6模块使用`import`和`export`关键字导入和导出模块；而CommonJS模块使用`require()`函数来导入模块，使用`module.exports`来导出模块
- 动态与静态：ES6模块是静态的，再代码解析阶段就已经确定了，无法改变其值，而CommonJS模块是动态的，导入导出发生在运行时
- 异步与同步的加载方式：ES6模块支持异步加载，而CommonJS的加载是同步的

------

#### 28. 对DOM节点的操作

- 获取：

  ```js
  document.getElementById // 按照 id 查询
  document.getElementsByTagName // 按照标签名查询
  document.getElementsByClassName // 按照类名查询
  document.querySelectorAll // 按照 css 选择器查询
  ```

- 创建：

  ```js
  // 首先获取父节点
  var fatherNode = document.getElementById('fatherNode')
  // 创建新节点
  var sonNode = document.createElement('span')
  // 设置子节点的内容
  sonNode.innerHTML = 'hello world'
  // 把新创建的元素塞进父节点里去
  fatherNode.appendChild(sonNode)
  ```

- 删除：

  ```js
  // 获取目标元素的父元素
  var fatherNode = document.getElementById('fatherNode')
  // 获取目标元素
  var sonNode = document.getElementById('sonNode')
  // 删除目标元素
  fatherNode.removeChild(sonNode)
  ```

- 交换：

  ```js
  // 获取父元素
  var fatherNode = document.getElementById('fatherNode')   
  // 获取两个需要被交换的元素
  var sonNode = document.getElementById('sonNode')
  var daughterNode = document.getElementById('daughterNode')
  // 交换两个元素，把 daughterNode 置于 sonNode 前面
  fatherNode.insertBefore(daughterNode, sonNode)
  ```

------

#### 29. use strict

use strict，即严格模式，在这种模式下运行的JS的性能会得到提升，其主要功能如下：

- 消除 Javascript 语法的不合理、不严谨之处，减少怪异行为
- 消除代码运行的不安全之处，保证代码运行的安全
- 提高编译器效率，增加运行速度
- 为未来新版本的 Javascript 做好铺垫

其限制主要体现在：禁止将this指向全局对象，对象不能有重名属性

------

#### 30. for...in和for...of的区别

- for...in遍历的是对象的键名，主要用于遍历对象，不适用于遍历数组
- for...of遍历的是键值，主要用于遍历数组、类数组对象、字符串、Set、Map以及Generator对象

------

#### 31. ajax、axios、fetch的区别

- ajax：指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新
- fetch：号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。**fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象**
- axios：是一种基于Promise封装的HTTP客户端，基于ajax，属于对ajax的封装，同样支持Promise API，还能监听请求和返回，自动转化json数据

------

#### 32. 数组的遍历方法有哪些

| **方法**                  | **是否改变原数组** | **特点**                                                     |
| ------------------------- | ------------------ | ------------------------------------------------------------ |
| forEach()                 | 否                 | 数组方法，不改变原数组，没有返回值                           |
| map()                     | 否                 | 数组方法，不改变原数组，有返回值，可链式调用                 |
| filter()                  | 否                 | 数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用 |
| for...of                  | 否                 | for...of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环 |
| every() 和 some()         | 否                 | 数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false. |
| find() 和 findIndex()     | 否                 | 数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值 |
| reduce() 和 reduceRight() | 否                 | 数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作 |

------

#### 33. forEach和map方法的区别

forEach会直接操作原数组，没有返回值；map则不会改变原数组，而是返回一个新数组

------

#### 34. 对原型、原型链的理解

- 原型：每个**函数**都有prototype属性，称之为**原型**，因为整个属性值是一个对象，因此也称其为原型对象。这个对象包含了可以由该构造函数的所有实例共享的属性和方法。并且由该构造函数所创建的实例身上都有一个`__proto__`的属性，其值就是构造函数的**原型**
- 原型链：凡是对象都有`__proto__`属性，当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象本质上也是一个对象，因此也会有自己的原型对象，于是就这样一直找下去，就形成了原型链的概念。原型链的**尽头**一般来说都是 Object.prototype，因为再往下找就是**终点**null了

------

#### 35. 对闭包的理解

**闭包是指有权访问另一个函数作用域中变量的函数**，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。

闭包有两个常用的用途；

- 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。
- 闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收，当然滥用也可能导致内存泄漏

------

#### 36. 对this的理解

this是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断：

- 函数调用模式：当一个函数不是一个对象的属性时，**直接作为函数来调用**时，this指向**全局对象**
- 方法调用模式：如果一个函数作为**一个对象的方法**来调用时，this 指向这个对象
- 构造器调用模式：如果一个函数用new调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象，通常是new操作符创建的对象
- apply、call、bind调用模式：可以修改this的指向

以上四个方法this指向的优先级：构造器调用模式>apply、call 和bind调用模式>方法调用模式>函数调用模式

------

#### 37. call()、apply()、bind()三者的区别

|  函数   |    返回值    |                             参数                             |         执行时机         |
| :-----: | :----------: | :----------------------------------------------------------: | :----------------------: |
| call()  |      无      | 第一个参数是指定的this的指向（若为null或undefined，则默认指向window），第二个参数是调用call的函数的参数，但是要以参数列表的形式传递（即参数用逗号分隔一个个传） | 改变指向后立即执行原函数 |
| apply() |      无      | 第一个参数是指定的this的指向（若为null或undefined，则默认指向window），第二个参数是调用apply的函数的参数，但是要以数组的形式传递 | 改变指向后立即执行原函数 |
| bind()  | 返回一个函数 | 第一个参数是指定的this的指向（若为null或undefined，则默认指向window），第二个参数是调用bind的函数的参数，但是要以参数列表的形式传递（即参数用逗号分隔一个个传） |    不会立刻执行原函数    |

------

#### 38. setTimeout、Promise、async/await的区别

- setTimeout：属于异步代码，在宏任务队列中执行，当执行到setTimeout时会将其回调单独抽离出来，等待延迟时间结束并且当前执行的宏任务队列清空，再将回调放入新的宏任务队列中执行
- Promise：属于同步代码，当浏览器解析到Promise时会将其回调立刻执行，再判断Promise的状态，再执行状态所对应的回调，以上过程都是立刻执行的同步代码。当当前宏任务队列执行完毕，才会执行宏任务队列产生的微任务队列，即Promise.then()或Promise.catch()的回调
- async/await：（前端大部分场景）属于Promise的语法糖，给一个函数加上async关键字相当于给函数包了一层Promise对象。async函数的代码在遇到await之前都属于立刻执行的同步代码，当遇到await就会将其后直至函数体结束的所有代码单独拿出来，async函数中断，进入pending状态，直到await的表达式返回了结果，才会将之前拿出来的代码加入微任务队列中，待当前宏任务队列执行完毕后才会执行

------

#### 39. Promise的优缺点：

- 优点：提供了统一的API，可以获取异步操作的消息，避免了地狱回调，比传统的解决方案回调函数和事件更合理和更强大
- 缺点：无法取消Promise，一旦新建它就会立即执行，无法中途取消；如果不设置回调函数，Promise内部抛出的错误，不会反应到外部；当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）

------

#### 40. async/await对比Promise的优势

- 代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担
- Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅
- 错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获非常冗余
- 调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步

------

#### 41. 浏览器的垃圾回收机制

- 标记清除：是浏览器常见的垃圾回收方式。当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。
- 引用记数：使用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，这个变量所占有的内存空间就会被释放出来。但也因此诞生了一个问题，如果两个变量互相引用，会导致引用次数不能为0，导致内存不能释放，这时候需要将其值赋为null手动释放内存

------

#### 42. 如何对垃圾回收优化

- 数组：在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的
- 对象：对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收
- 函数：在循环中的函数表达式，如果可以复用，尽量放在函数的外面

------

#### 43. 什么情况会造成内存泄漏

- 意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收
- 遗忘的定时器：设置了过多的定时器而没有及时关闭
- 脱离DOM的引用：**：** 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收
- 闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中

